knitr::opts_chunk$set(echo = TRUE, warning=FALSE, message=FALSE, fig.cap = " ", fig.path='figs/')
library(sandwich)
# Install sandwich package
# install.packages("sandwich")
# Import sandwich package
library("sandwich")
# Calculate the geographical detector q-statistic
ssh.test(object=bc.join, y="Incidence", x="SSHID", test="factor")
# Calculate the geographical detector q-statistic
ssh.test(object=bc.join, y="Incidence", x="SSHID", test="factor", type="txt")
# Perform the SSH based spatial interpolation
bc.sw <- sandwich.model(object=bc.data, sampling.attr="Incidence", type="txt", ssh.id.col="SSHID", ssh.weights=list(c(1,2), c("W1","W2")))
head(bc.sw)
View(bc.sw)
# Calculate the confidence intervals of the interpolation estimates
bc.sw.ci <- sandwich.ci(object=bc.sw, level=.95)
head(bc.sw.ci)
# Perform k-fold cross validation
bc.cv <- sandwich.cv(object=bc.data, sampling.attr="Incidence", k=5, type="txt", ssh.id.col="SSHID", reporting.id.col="GBCODE", ssh.weights=list(c(1,2), c("W1","W2")))
bc.cv
devtools::load_all(".")
# Perform the SSH based spatial interpolation
bc.sw <- sandwich.model(object=bc.data, sampling.attr="Incidence", type="txt", ssh.id.col="SSHID", ssh.weights=list(c(1,2), c("W1","W2")))
head(bc.sw)
# Install sandwich package
# install.packages("sandwich")
# Import sandwich package
library("sandwich")
# Perform the SSH based spatial interpolation
bc.sw <- sandwich.model(object=bc.data, sampling.attr="Incidence", type="txt", ssh.id.col="SSHID", ssh.weights=list(c(1,2), c("W1","W2")))
head(bc.sw)
devtools::load_all(".")
# Perform the SSH based spatial interpolation
bc.sw <- sandwich.model(object=bc.data, sampling.attr="Incidence", type="txt", ssh.id.col="SSHID", ssh.weights=list(c(1,2), c("W1","W2")))
head(bc.sw)
devtools::load_all(".")
# Perform the SSH based spatial interpolation
bc.sw <- sandwich.model(object=bc.data, sampling.attr="Incidence", type="txt", ssh.id.col="SSHID", ssh.weights=list(c(1,2), c("W1","W2")))
head(bc.sw)
unlink('vignettes/sandwich.r.tutorial_cache', recursive = TRUE)
devtools::load_all(".")
devtools::load_all(".")
knitr::opts_chunk$set(echo = TRUE, warning=FALSE, message=FALSE, fig.cap = " ", fig.path='figs/')
# Install sandwich package
# install.packages("sandwich")
# Import sandwich package
library("sandwich")
# Perform the SSH based spatial interpolation
bc.sw <- sandwich.model(object=bc.data, sampling.attr="Incidence", type="txt", ssh.id.col="SSHID", ssh.weights=list(c(1,2), c("W1","W2")))
head(bc.sw)
unlink('vignettes/sandwich.r.tutorial_cache', recursive = TRUE)
knitr::opts_chunk$set(echo = TRUE, warning=FALSE, message=FALSE, fig.cap = " ", fig.path='figs/')
# Install sandwich package
# install.packages("sandwich")
# Import sandwich package
library("sandwich")
# Input data from shapefiles
hs.data <- load.data.shp(path="./data", sampling.file="hs.sampling.shapefile",
ssh.file="hs.ssh.shapefile", reporting.file="hs.reporting.shapefile")
# Input another candidate SSH layer for demonstration
hs.ssh2 <- read_sf(dsn="./data", layer="hs.ssh2.shapefile")
# Prepare the SSH layer(s) for evaluation
hs.join <- ssh.data.shp(object=hs.data[[1]], ssh.lyr=hs.data[[2]], ssh.id="STR_1")
hs.join <- ssh.data.shp(object=hs.join, ssh.lyr=hs.ssh2, ssh.id="STR_2")
head(hs.join)
# Calculate the geographical detector q-statistic
ssh.test(object=hs.join, y="Population", x=c("STR_1", "STR_2"), test="factor")
# Calculate the interaction detector
ssh.test(object=hs.join, y="Population", x=c("STR_1", "STR_2"), test="interaction")
# Perform the SSH based spatial interpolation
hs.sw <- sandwich.model(object=hs.data, sampling.attr="Population", type="shp")
head(hs.sw)
# Plot the mean values of the interpolation estimates
plot.mean(object=hs.sw)
# Plot the standard errors of the interpolation estimates
plot.se(object=hs.sw)
# Calculate the confidence intervals of the interpolation estimates
hs.sw.ci <- sandwich.ci(object=hs.sw, level=.95)
head(hs.sw.ci)
# Plot the confidence intervals of the interpolation estimates
plot.ci(object=hs.sw.ci)
# Perform k-fold cross validation
hs.cv <- sandwich.cv(object=hs.data, sampling.attr="Population", k=5, type="shp")
hs.cv
# Input data from text files
bc.data <- load.data.txt(sampling_ssh.file="./data/bc_sampling_ssh.csv",
reporting_ssh.file="./data/bc_reporting_ssh.csv")
# Sampling-SSH
head(bc.data[[1]])
# Reporting-SSH
head(bc.data[[2]])
# Prepare the SSH layer for evaluation
bc.join <- ssh.data.txt(object=bc.data)
head(bc.join)
# Calculate the geographical detector q-statistic
ssh.test(object=bc.join, y="Incidence", x="SSHID", test="factor", type="txt")
# Perform the SSH based spatial interpolation
bc.sw <- sandwich.model(object=bc.data, sampling.attr="Incidence", type="txt", ssh.id.col="SSHID", ssh.weights=list(c(1,2), c("W1","W2")))
head(bc.sw)
# Calculate the confidence intervals of the interpolation estimates
bc.sw.ci <- sandwich.ci(object=bc.sw, level=.95)
head(bc.sw.ci)
# Perform k-fold cross validation
bc.cv <- sandwich.cv(object=bc.data, sampling.attr="Incidence", k=5, type="txt", ssh.id.col="SSHID", reporting.id.col="GBCODE", ssh.weights=list(c(1,2), c("W1","W2")))
head(bc.cv)
devtools::load_all(".")
library(sandwich)
roxygen2::roxygenise()
devtools::build_manual()
devtools::build_vignettes()
.Last.error.trace
bc.data[1,][["W1"]]
bc.data[[2]][1,][["W1"]]
bc.data[[2]][1,][["W1"]] != 0
bc.data[[2]][3,][["W1"]] !=0
bc.data[[2]][4,][["W1"]] !=0
bc.data[[2]][4,][["W2"]] !=0
getwd()
library(sandwich)
devtools::build_vignettes()
roxygen2::roxygenise()
devtools::build_manual()
roxygen2::roxygenise()
devtools::build_manual()
roxygen2::roxygenise()
devtools::build_manual()
roxygen2::roxygenise()
devtools::build_manual()
roxygen2::roxygenise()
devtools::build_manual()
roxygen2::roxygenise()
devtools::build_manual()
devtools::build_vignettes()
devtools::build_vignettes()
devtools::build_vignettes()
.Last.error.trace
devtools::build_vignettes()
roxygen2::roxygenise()
devtools::build_manual()
roxygen2::roxygenise()
devtools::build_manual()
knitr::opts_chunk$set(echo = TRUE, warning=FALSE, message=FALSE, fig.cap = " ", fig.path='figs/')
# Install sandwich package
# install.packages("sandwich")
# Import sandwich package
library("sandwich")
# Input data from shapefiles
hs.data <- load.data.shp(path="./data", sampling.file="hs.sampling.shapefile",
ssh.file="hs.ssh.shapefile", reporting.file="hs.reporting.shapefile")
# Input another candidate SSH layer for demonstration
hs.ssh2 <- read_sf(dsn="./data", layer="hs.ssh2.shapefile")
# Prepare the SSH layer(s) for evaluation
hs.join <- ssh.data.shp(object=hs.data[[1]], ssh.lyr=hs.data[[2]], ssh.id="STR_1")
hs.join <- ssh.data.shp(object=hs.join, ssh.lyr=hs.ssh2, ssh.id="STR_2")
head(hs.join)
# Calculate the geographical detector q-statistic
ssh.test(object=hs.join, y="Population", x=c("STR_1", "STR_2"), test="factor")
# Calculate the interaction detector
ssh.test(object=hs.join, y="Population", x=c("STR_1", "STR_2"), test="interaction")
# Perform the SSH based spatial interpolation
hs.sw <- sandwich.model(object=hs.data, sampling.attr="Population", type="shp")
head(hs.sw)
# Plot the mean values of the interpolation estimates
plot.mean(object=hs.sw)
# Plot the standard errors of the interpolation estimates
plot.se(object=hs.sw)
# Calculate the confidence intervals of the interpolation estimates
hs.sw.ci <- sandwich.ci(object=hs.sw, level=.95)
head(hs.sw.ci)
# Plot the confidence intervals of the interpolation estimates
plot.ci(object=hs.sw.ci)
# Perform k-fold cross validation
hs.cv <- sandwich.cv(object=hs.data, sampling.attr="Population", k=5, type="shp")
hs.cv
# Input data from text files
bc.data <- load.data.txt(sampling_ssh.file="./data/bc_sampling_ssh.csv",
reporting_ssh.file="./data/bc_reporting_ssh.csv")
# Sampling-SSH
head(bc.data[[1]])
# Reporting-SSH
head(bc.data[[2]])
# Prepare the SSH layer for evaluation
bc.join <- ssh.data.txt(object=bc.data)
head(bc.join)
# Calculate the geographical detector q-statistic
ssh.test(object=bc.join, y="Incidence", x="SSHID", test="factor", type="txt")
# Perform the SSH based spatial interpolation
bc.sw <- sandwich.model(object=bc.data, sampling.attr="Incidence", type="txt",
ssh.id.col="SSHID", ssh.weights=list(c(1,2), c("W1","W2")))
head(bc.sw)
# Calculate the confidence intervals of the interpolation estimates
bc.sw.ci <- sandwich.ci(object=bc.sw, level=.95)
head(bc.sw.ci)
# Perform k-fold cross validation
bc.cv <- sandwich.cv(object=bc.data, sampling.attr="Incidence", k=5, type="txt",
ssh.id.col="SSHID", reporting.id.col="GBCODE",
ssh.weights=list(c(1,2), c("W1","W2")))
head(bc.cv)
writeOGR(hs.sw.ci, ".", "hs.sw.ci", driver = "ESRI Shapefile")
library(rgdal)
writeOGR(hs.sw.ci, ".", "hs.sw.ci", driver = "ESRI Shapefile")
writeOGR(hs.sw.ci, ".", "hs.sw.ci.shp", driver = "ESRI Shapefile")
hs.sw.ci
writeOGR(hs.sw.ci, dsn = ".", layer = "hs.sw.ci",
driver = "ESRI Shapefile" )
sf::st_write(obj = hs.sw.ci, dsn = "hs.sw.ci.shp")
write.csv(bc.sw.ci, "bc.sw.ci.csv")
mean(bc.sw.ci$se)
max(bc.sw.ci$se)
max(bc.sw.ci$ci.up-bc.sw.ci$ci.low)
mean(bc.sw.ci$ci.up-bc.sw.ci$ci.low)
knitr::opts_chunk$set(echo = TRUE, warning=FALSE, message=FALSE, fig.cap = " ", fig.path='figs/')
# Install sandwich package
# install.packages("sandwich")
# Import sandwich package
library("sandwich")
# Input data from shapefiles
hs.data <- load.data.shp(path="./data", sampling.file="hs.sampling.shapefile",
ssh.file="hs.ssh.shapefile", reporting.file="hs.reporting.shapefile")
# Input another candidate SSH layer for demonstration
hs.ssh2 <- read_sf(dsn="./data", layer="hs.ssh2.shapefile")
# Prepare the SSH layer(s) for evaluation
hs.join <- ssh.data.shp(object=hs.data[[1]], ssh.lyr=hs.data[[2]], ssh.id="STR_1")
hs.join <- ssh.data.shp(object=hs.join, ssh.lyr=hs.ssh2, ssh.id="STR_2")
head(hs.join)
# Calculate the geographical detector q-statistic
ssh.test(object=hs.join, y="Population", x=c("STR_1", "STR_2"), test="factor")
roxygen2::roxygenise()
devtools::build_vignettes()
st_write(hs.sw.ci, "hs.sw.ci.shp")
mean(hs.sw.ci$mean)
range(hs.sw.ci$mean)
mean(hs.sw.ci$se)
mean(hs.sw.ci$ci.up-hs.sw.ci$ci.low)
knitr::opts_chunk$set(echo = TRUE)
install.packages("mipfp")
install.packages("png")
install.packages("bookdown")
install.packages("bookdown")
knitr::opts_chunk$set(echo = TRUE)
import("mipfp")
library("mipfp")
roxygen2::roxygenise()
devtools::build_manual()
devtools::build_vignettes()
devtools::build_vignettes()
sf::st_write(obj = hs.sw.ci, dsn = "hs.sw.ci.shp")
knitr::opts_chunk$set(echo = TRUE, warning=FALSE, message=FALSE, fig.cap = " ", fig.path='figs/')
# Mean +/- standard deviation
ggerrorplot(bc.data[[1]], x = "SSHID", y = "Incidence",
desc_stat = "mean_sd")
# Change error plot type and add mean points
ggerrorplot(ToothGrowth, x = "SSHID", y = "Incidence",
desc_stat = "mean_sd",
error.plot = "errorbar",            # Change error plot type
add = "mean"                        # Add mean points
)
install.packages("ggpubr")
library(ggpubr)
# Mean +/- standard deviation
ggerrorplot(bc.data[[1]], x = "SSHID", y = "Incidence",
desc_stat = "mean_sd")
# Change error plot type and add mean points
ggerrorplot(ToothGrowth, x = "SSHID", y = "Incidence",
desc_stat = "mean_sd",
error.plot = "errorbar",            # Change error plot type
add = "mean"                        # Add mean points
)
library(ggpubr)
# Mean +/- standard deviation
ggerrorplot(bc.data[[1]], x = "SSHID", y = "Incidence",
desc_stat = "mean_sd")
# Change error plot type and add mean points
ggerrorplot(bc.data[[1]], x = "SSHID", y = "Incidence",
desc_stat = "mean_sd",
error.plot = "errorbar",            # Change error plot type
add = "mean"                        # Add mean points
)
library(ggpubr)
ggerrorplot(bc.data[[1]], x = "SSHID", y = "Incidence",
desc_stat = "mean_sd", color = "black",
add = "dotplot", add.params = list(color = "darkgray")
)
library(ggpubr)
ggerrorplot(bc.data[[1]], x = "SSHID", y = "Incidence",
desc_stat = "mean_sd", color = "black",
add = "violin", add.params = list(color = "darkgray")
)
devtools::build_vignettes()
library(ggpubr)
p = ggerrorplot(bc.data[[1]], x = "SSHID", y = "Incidence",
desc_stat = "mean_sd", color = "black",
add = "violin", add.params = list(color = "darkgray")
)
p + scale_x_discrete(labels=c("1" = "Urban", "2" = "Rural")) +
theme(axis.title.x = element_blank())
devtools::build_vignettes()
devtools::build_vignettes()
knitr::opts_chunk$set(echo = TRUE, warning=FALSE, message=FALSE, fig.cap = " ", fig.path='figs/')
library(ggpubr)
p = ggerrorplot(bc.data[[1]], x = "SSHID", y = "Incidence",
desc_stat = "mean_sd", color = "black",
add = "violin", add.params = list(color = "darkgray")
)
p + scale_x_discrete(labels=c("1" = "Urban", "2" = "Rural")) +
theme(axis.title.x = element_blank())
library(ggpubr)
p = ggerrorplot(bc.data[[1]], x = "SSHID", y = "Incidence",
desc_stat = "mean_sd", color = "black",
add = "violin", add.params = list(color = "darkgray")
)
p + scale_x_discrete(labels=c("1" = "Urban", "2" = "Rural")) +
theme(axis.title.x = element_blank())
bc.data[[1]] %>%
group_by(SSHID) %>%
summarise_at(vars(Incidence),
list(name = mean))
library(ggpubr)
library(dplyr)
p = ggerrorplot(bc.data[[1]], x = "SSHID", y = "Incidence",
desc_stat = "mean_sd", color = "black",
add = "violin", add.params = list(color = "darkgray")
)
p + scale_x_discrete(labels=c("1" = "Urban", "2" = "Rural")) +
theme(axis.title.x = element_blank())
bc.data[[1]] %>%
group_by(SSHID) %>%
summarise_at(vars(Incidence),
list(name = mean))
devtools::build_vignettes()
devtools::build_vignettes()
devtools::build_vignettes()
knitr::opts_chunk$set(echo = TRUE, warning=FALSE, message=FALSE, fig.cap = " ", fig.path='figs/')
# Perform k-fold cross validation
bc.cv <- sandwich.cv(object=bc.data, sampling.attr="Incidence", k=5, type="txt",
ssh.id.col="SSHID", reporting.id.col="GBCODE",
ssh.weights=list(c(1,2), c("W1","W2")))
head(bc.cv)
devtools::load_all(".")
library(sandwich)
devtools::build_vignettes()
knitr::opts_chunk$set(echo = TRUE, warning=FALSE, message=FALSE, fig.cap = " ", fig.path='figs/')
# Perform k-fold cross validation
bc.cv <- sandwich.cv(object=bc.data, sampling.attr="Incidence", k=5, type="txt",
ssh.id.col="SSHID", reporting.id.col="GBCODE",
ssh.weights=list(c(1,2), c("W1","W2")))
head(bc.cv)
knitr::opts_chunk$set(echo = TRUE, warning=FALSE, message=FALSE, fig.cap = " ", fig.path='figs/')
# Install sandwich package
# install.packages("sandwich")
# Import sandwich package
library("sandwich")
# Input data from shapefiles
hs.data <- load.data.shp(path="./data", sampling.file="hs.sampling.shapefile",
ssh.file="hs.ssh.shapefile", reporting.file="hs.reporting.shapefile")
# Input another candidate SSH layer for demonstration
hs.ssh2 <- read_sf(dsn="./data", layer="hs.ssh2.shapefile")
# Prepare the SSH layer(s) for evaluation
hs.join <- ssh.data.shp(object=hs.data[[1]], ssh.lyr=hs.data[[2]], ssh.id="STR_1")
hs.join <- ssh.data.shp(object=hs.join, ssh.lyr=hs.ssh2, ssh.id="STR_2")
head(hs.join)
# Calculate the geographical detector q-statistic
ssh.test(object=hs.join, y="Population", x=c("STR_1", "STR_2"), test="factor")
# Calculate the interaction detector
ssh.test(object=hs.join, y="Population", x=c("STR_1", "STR_2"), test="interaction")
# Perform the SSH based spatial interpolation
hs.sw <- sandwich.model(object=hs.data, sampling.attr="Population", type="shp")
head(hs.sw)
# Plot the mean values of the interpolation estimates
plot.mean(object=hs.sw)
# Plot the standard errors of the interpolation estimates
plot.se(object=hs.sw)
# Calculate the confidence intervals of the interpolation estimates
hs.sw.ci <- sandwich.ci(object=hs.sw, level=.95)
head(hs.sw.ci)
# Plot the confidence intervals of the interpolation estimates
plot.ci(object=hs.sw.ci)
# Perform k-fold cross validation
hs.cv <- sandwich.cv(object=hs.data, sampling.attr="Population", k=5, type="shp")
hs.cv
# Input data from text files
bc.data <- load.data.txt(sampling_ssh.file="./data/bc_sampling_ssh.csv",
reporting_ssh.file="./data/bc_reporting_ssh.csv")
# Sampling-SSH
head(bc.data[[1]])
# Reporting-SSH
head(bc.data[[2]])
# Prepare the SSH layer for evaluation
bc.join <- ssh.data.txt(object=bc.data)
head(bc.join)
# Calculate the geographical detector q-statistic
ssh.test(object=bc.join, y="Incidence", x="SSHID", test="factor", type="txt")
library(ggpubr)
library(dplyr)
p = ggerrorplot(bc.data[[1]], x = "SSHID", y = "Incidence",
desc_stat = "mean_sd", color = "black",
add = "violin", add.params = list(color = "darkgray")
)
p + scale_x_discrete(labels=c("1" = "Urban", "2" = "Rural")) +
theme(axis.title.x = element_blank())
bc.data[[1]] %>%
group_by(SSHID) %>%
summarise_at(vars(Incidence),
list(name = mean))
# Perform the SSH based spatial interpolation
bc.sw <- sandwich.model(object=bc.data, sampling.attr="Incidence", type="txt",
ssh.id.col="SSHID", ssh.weights=list(c(1,2), c("W1","W2")))
head(bc.sw)
# Calculate the confidence intervals of the interpolation estimates
bc.sw.ci <- sandwich.ci(object=bc.sw, level=.95)
head(bc.sw.ci)
# Perform k-fold cross validation
bc.cv <- sandwich.cv(object=bc.data, sampling.attr="Incidence", k=5, type="txt",
ssh.id.col="SSHID", reporting.id.col="GBCODE",
ssh.weights=list(c(1,2), c("W1","W2")))
head(bc.cv)
# Perform k-fold cross validation
bc.cv <- sandwich.cv(object=bc.data, sampling.attr="Incidence", k=5, type="txt",
ssh.id.col="SSHID", reporting.id.col="GBCODE",
ssh.weights=list(c(1,2), c("W1","W2")))
bc.cv
# Perform k-fold cross validation
bc.cv <- sandwich.cv(object=bc.data, sampling.attr="Incidence", k=5, type="txt",
ssh.id.col="SSHID", reporting.id.col="GBCODE",
ssh.weights=list(c(1,2), c("W1","W2")))
bc.cv
devtools::build_vignettes()
devtools::build_vignettes()
# Perform k-fold cross validation
bc.cv <- sandwich.cv(object=bc.data, sampling.attr="Incidence", k=5, type="txt",
ssh.id.col="SSHID", reporting.id.col="GBCODE",
ssh.weights=list(c(1,2), c("W1","W2")))
knitr::opts_chunk$set(echo = TRUE, warning=FALSE, message=FALSE, fig.cap = " ", fig.path='figs/')
# Install sandwich package
# install.packages("sandwich")
# Import sandwich package
library("sandwich")
# Input data from shapefiles
hs.data <- load.data.shp(path="./data", sampling.file="hs.sampling.shapefile",
ssh.file="hs.ssh.shapefile", reporting.file="hs.reporting.shapefile")
# Input another candidate SSH layer for demonstration
hs.ssh2 <- read_sf(dsn="./data", layer="hs.ssh2.shapefile")
# Prepare the SSH layer(s) for evaluation
hs.join <- ssh.data.shp(object=hs.data[[1]], ssh.lyr=hs.data[[2]], ssh.id="STR_1")
hs.join <- ssh.data.shp(object=hs.join, ssh.lyr=hs.ssh2, ssh.id="STR_2")
head(hs.join)
# Calculate the geographical detector q-statistic
ssh.test(object=hs.join, y="Population", x=c("STR_1", "STR_2"), test="factor")
# Calculate the interaction detector
ssh.test(object=hs.join, y="Population", x=c("STR_1", "STR_2"), test="interaction")
# Perform the SSH based spatial interpolation
hs.sw <- sandwich.model(object=hs.data, sampling.attr="Population", type="shp")
head(hs.sw)
# Plot the mean values of the interpolation estimates
plot.mean(object=hs.sw)
# Plot the standard errors of the interpolation estimates
plot.se(object=hs.sw)
# Calculate the confidence intervals of the interpolation estimates
hs.sw.ci <- sandwich.ci(object=hs.sw, level=.95)
head(hs.sw.ci)
# Plot the confidence intervals of the interpolation estimates
plot.ci(object=hs.sw.ci)
# Perform k-fold cross validation
hs.cv <- sandwich.cv(object=hs.data, sampling.attr="Population", k=5, type="shp")
hs.cv
# Input data from text files
bc.data <- load.data.txt(sampling_ssh.file="./data/bc_sampling_ssh.csv",
reporting_ssh.file="./data/bc_reporting_ssh.csv")
# Sampling-SSH
head(bc.data[[1]])
# Reporting-SSH
head(bc.data[[2]])
# Prepare the SSH layer for evaluation
bc.join <- ssh.data.txt(object=bc.data)
head(bc.join)
# Calculate the geographical detector q-statistic
ssh.test(object=bc.join, y="Incidence", x="SSHID", test="factor", type="txt")
library(ggpubr)
library(dplyr)
p = ggerrorplot(bc.data[[1]], x = "SSHID", y = "Incidence",
desc_stat = "mean_sd", color = "black",
add = "violin", add.params = list(color = "darkgray")
)
p + scale_x_discrete(labels=c("1" = "Urban", "2" = "Rural")) +
theme(axis.title.x = element_blank())
bc.data[[1]] %>%
group_by(SSHID) %>%
summarise_at(vars(Incidence),
list(name = mean))
# Perform the SSH based spatial interpolation
bc.sw <- sandwich.model(object=bc.data, sampling.attr="Incidence", type="txt",
ssh.id.col="SSHID", ssh.weights=list(c(1,2), c("W1","W2")))
head(bc.sw)
# Calculate the confidence intervals of the interpolation estimates
bc.sw.ci <- sandwich.ci(object=bc.sw, level=.95)
head(bc.sw.ci)
# Perform k-fold cross validation
bc.cv <- sandwich.cv(object=bc.data, sampling.attr="Incidence", k=5, type="txt",
ssh.id.col="SSHID", reporting.id.col="GBCODE",
ssh.weights=list(c(1,2), c("W1","W2")))
bc.cv
devtools::build_vignettes()
range(hs.sw.ci$mean)
mean(hs.sw.ci$se)
mean(hs.sw.ci$ci.up - hs.sw.ci$ci.low)
mean(hs.sw.ci$ci.up - hs.sw.ci$ci.low)/2
range(bc.sw.ci$mean)
mean(hs.sw.ci$se)
mean(bc.sw.ci$se)
max(bc.sw.ci$se)
mean(bc.sw.ci$ci.up - bc.sw.ci$ci.low)/2
write.csv(bc.sw.ci,"bc.sw.ci.csv")
